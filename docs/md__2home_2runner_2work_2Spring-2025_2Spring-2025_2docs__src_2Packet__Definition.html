<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ASCEND Flight Software: More on The Packeting System</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ASCEND Flight Software
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">More on The Packeting System</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md19"></a> </p>
<h1><a class="anchor" id="autotoc_md20"></a>
Previous Iteration</h1>
<p>Last semester our packets were text and csv based, with the first csv cell serving as a Header code. Iterating through the sensors, each sensor would append its csv fields onto the packet string and toggle its corresponding bit in the Header</p>
<h1><a class="anchor" id="autotoc_md21"></a>
The Header</h1>
<p>The Header is a 32 bit unsigned integer that is treated like just an array of bits, so when a sensor’s data is added to the packet string, its corresponding bit is set. The procedure for setting each bit is as follows:</p>
<div class="fragment"><div class="line">SHIFT Header left by 1</div>
<div class="line">IF sensor is read</div>
<div class="line">    Set leftmost Header bit to 1 (Header = Header | 1) (bitwise OR)</div>
<div class="line">ELSE </div>
<div class="line">    Set leftmost Header bit to 0 (do nothing) </div>
</div><!-- fragment --><p>So with a sensor setup defined as follows: </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><a class="el" href="classSensor.html" title="Parent class for sensor objects.">Sensor</a>   </th><th class="markdownTableHeadNone">CSV Header snippet    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Millis()   </td><td class="markdownTableBodyNone">“Millis, ”    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Temp   </td><td class="markdownTableBodyNone">“TempF,”    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">BME280   </td><td class="markdownTableBodyNone">“TempC, PresshPa, RelHum%, ”   </td></tr>
</table>
<p>Header starts as 0000 0000 0000 0001 with a bit for the header value itself as it is a cell in the csv CSV Header starts as “Header, ”</p>
<p>Then when a sensor is read in order ones are shifted in (in this case we’ll assume Temp is being skipped)</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><a class="el" href="classSensor.html" title="Parent class for sensor objects.">Sensor</a> Visited   </th><th class="markdownTableHeadNone">Header Val (in hex)   </th><th class="markdownTableHeadNone">CSV Header   </th><th class="markdownTableHeadNone">CSV Row(dummy values)    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Millis   </td><td class="markdownTableBodyNone">0000 0000 0000 0011   </td><td class="markdownTableBodyNone">“Header, Millis, ”   </td><td class="markdownTableBodyNone">“(header val), 84949, ”    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Temp   </td><td class="markdownTableBodyNone">0000 0000 0000 0110   </td><td class="markdownTableBodyNone">“Header, Millis, ”   </td><td class="markdownTableBodyNone">“(header val), 84949, ”    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">BME280   </td><td class="markdownTableBodyNone">0000 0000 0000 1101   </td><td class="markdownTableBodyNone">“Header, Millis, TempC, PresshPa, RelHum%, ”   </td><td class="markdownTableBodyNone">“(header val), 84949, 18, 30, 15, ”   </td></tr>
</table>
<p>So when this is decoded the header is populated by a header with corresponding definitions in the ground software, which lets them know what the values mean.</p>
<h1><a class="anchor" id="autotoc_md22"></a>
Changes for this iteration</h1>
<p>This semester, expanding on those ideas, the new packeting scheme uses the same logic, but without the data values being stored as csv strings. This scheme relies on an understanding of pointers, if you’re not familiar with pointers I would recommend reviewing them, here’s a helpful short video: <a href="https://www.youtube.com/watch?v=2ybLD6_2gKM">https://www.youtube.com/watch?v=2ybLD6_2gKM</a></p>
<p>So instead we start with</p>
<p>Header for the system as 0000 0000 0000 0000 (now called sensor presence as Header becomes more complex)</p>
<p>And the packet as an array of uint8_t (plain bytes)</p>
<h3><a class="anchor" id="autotoc_md23"></a>
Packet Definition</h3>
<p><img src="images/Packet_Definition.png" alt="Packet Definition" width="100%" class="inline"/></p>
<h2><a class="anchor" id="autotoc_md24"></a>
Header</h2>
<h3><a class="anchor" id="autotoc_md25"></a>
ID/Sync Bytes</h3>
<p>These are predefined identifier bytes that allow the ground station to determine when a packet begins (4 Bytes). </p>
<h3><a class="anchor" id="autotoc_md26"></a>
Sensor Presence</h3>
<p>This serves the same purpose as last semester’s Header, 4 bytes has enough bits for all of our sensors </p>
<h3><a class="anchor" id="autotoc_md27"></a>
Packet Length</h3>
<p>The length of the entire packet in bytes. This is 2 bytes as an unsigned integer.</p>
<h2><a class="anchor" id="autotoc_md28"></a>
Data</h2>
<p>This is the largest difference for the packet this semester. Rather than encoding each value as characters and then transmitting a csv line, instead we are packing those values together. This allows for the packet to be smaller as instead of a byte for each character, we can represent numbers directly. For example, 8 bits as a character can only hold 10 values (0 to 9), but 8 bits as a number can hold 256 values (from 0 to 256 or -128 to 127).</p>
<p>To do this we use the copy function to transfer bytes directly from each value into the packet, then increment the packet, which as a pointer will then be used by the next sensor as the position to start writing its data. Another syntax thing to understand is that in C++ the &amp; on an argument’s data type indicates that it will be passed by reference, which means that the argument when changed and used is really changing and using the variable passed to it. In our case, incrementing the packet argument of the function will increment the packet variable passed to it, allowing each sensor to move the packet pointer as they add value to the packet.</p>
<p>The parent class functions that sensors need to override to implement the packeting system are </p><div class="fragment"><div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> readDataPacket(uint8_t*&amp; packet) {};</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">String decodeToCSV(uint8_t*&amp; packet) { <span class="keywordflow">return</span> <span class="stringliteral">&quot;&quot;</span>; };</div>
</div><!-- fragment --><p>And then an example of implementation from the Temperature <a class="el" href="classSensor.html" title="Parent class for sensor objects.">Sensor</a> class </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="classTempSensor.html#aef99face4fe66c0d41099a525c6af0e9">TempSensor::readDataPacket</a>(uint8_t*&amp; packet) {</div>
<div class="line">  <span class="comment">// read sensor value to a variable</span></div>
<div class="line">  <span class="keywordtype">float</span> <a class="code hl_variable" href="classDevice.html#a71f95d4b8d4a7af394d3e9c89ae87f7b">temp</a> = <a class="code hl_variable" href="classDevice.html#a71f95d4b8d4a7af394d3e9c89ae87f7b">analogReadTemp</a>();</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="comment">// cast the pointer to that value to a uint8_t pointer, copy the bytes at that pointer to packet (using the size of the variable to tell copy the number of bytes to copy)</span></div>
<div class="line">  std::copy((uint8_t*)(&amp;<a class="code hl_variable" href="classDevice.html#a71f95d4b8d4a7af394d3e9c89ae87f7b">temp</a>), (uint8_t*)(&amp;<a class="code hl_variable" href="classDevice.html#a71f95d4b8d4a7af394d3e9c89ae87f7b">temp</a>) + <span class="keyword">sizeof</span>(<a class="code hl_variable" href="classDevice.html#a71f95d4b8d4a7af394d3e9c89ae87f7b">temp</a>), <a class="code hl_variable" href="classDevice.html#a71f95d4b8d4a7af394d3e9c89ae87f7b">packet</a>);</div>
<div class="line">  <span class="comment">// increment the packet pointer past the new bytes</span></div>
<div class="line">  <a class="code hl_variable" href="classDevice.html#a71f95d4b8d4a7af394d3e9c89ae87f7b">packet</a> += <span class="keyword">sizeof</span>(<a class="code hl_variable" href="classDevice.html#a71f95d4b8d4a7af394d3e9c89ae87f7b">temp</a>);</div>
<div class="line">}</div>
<div class="ttc" id="aclassDevice_html_a71f95d4b8d4a7af394d3e9c89ae87f7b"><div class="ttname"><a href="classDevice.html#a71f95d4b8d4a7af394d3e9c89ae87f7b">Device::attempt_number</a></div><div class="ttdeci">int attempt_number</div><div class="ttdef"><b>Definition</b> Device.h:19</div></div>
<div class="ttc" id="aclassTempSensor_html_aef99face4fe66c0d41099a525c6af0e9"><div class="ttname"><a href="classTempSensor.html#aef99face4fe66c0d41099a525c6af0e9">TempSensor::readDataPacket</a></div><div class="ttdeci">void readDataPacket(uint8_t *&amp;packet) override</div><div class="ttdoc">Used for creating packets, reads data from the sensor and appends it to the passed uint8_t array poin...</div><div class="ttdef"><b>Definition</b> TempSensor.cpp:34</div></div>
</div><!-- fragment --><p> And then to decode we do the opposite (this will be used for testing the packet system and debugging in the time before the ground station decoding is set up) </p><div class="fragment"><div class="line">String <a class="code hl_function" href="classTempSensor.html#a4018ccd78833acd4ce610156649639a8">TempSensor::decodeToCSV</a>(uint8_t*&amp; packet) {</div>
<div class="line">  <span class="comment">// cast the packet pointer to pointer of the data type to read (float) then</span></div>
<div class="line">  <span class="comment">// dereference it</span></div>
<div class="line">  <span class="keywordtype">float</span> <a class="code hl_variable" href="classDevice.html#a71f95d4b8d4a7af394d3e9c89ae87f7b">temp</a>;</div>
<div class="line">  <a class="code hl_variable" href="classDevice.html#a71f95d4b8d4a7af394d3e9c89ae87f7b">memcpy</a>(&amp;<a class="code hl_variable" href="classDevice.html#a71f95d4b8d4a7af394d3e9c89ae87f7b">temp</a>, <a class="code hl_variable" href="classDevice.html#a71f95d4b8d4a7af394d3e9c89ae87f7b">packet</a>, <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>));</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="comment">// increment packet by the size of the read data type (float)</span></div>
<div class="line">  <a class="code hl_variable" href="classDevice.html#a71f95d4b8d4a7af394d3e9c89ae87f7b">packet</a> += <span class="keyword">sizeof</span>(<a class="code hl_variable" href="classDevice.html#a71f95d4b8d4a7af394d3e9c89ae87f7b">temp</a>);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="comment">// return in csv snippet format</span></div>
<div class="line">  <span class="keywordflow">return</span> String(<a class="code hl_variable" href="classDevice.html#a71f95d4b8d4a7af394d3e9c89ae87f7b">temp</a>) + <span class="stringliteral">&quot;,&quot;</span>;</div>
<div class="line">}</div>
<div class="ttc" id="aclassTempSensor_html_a4018ccd78833acd4ce610156649639a8"><div class="ttname"><a href="classTempSensor.html#a4018ccd78833acd4ce610156649639a8">TempSensor::decodeToCSV</a></div><div class="ttdeci">String decodeToCSV(uint8_t *&amp;packet) override</div><div class="ttdoc">Used for onboard decoding of packets.</div><div class="ttdef"><b>Definition</b> TempSensor.cpp:45</div></div>
</div><!-- fragment --><p> This all works because in C++, you can tell your program to interpret any pointer as any other pointer, which, to encode the data, lets us fake the data pointer being a pointer to a uint8_t array which can then be read byte by byte into the packet. And then to decode the packet, copy the data in reverse from the packet array to the appropriate data type variable.</p>
<p>NOTE: Before this we did recommend casting the pointer to decode the packet, which is something that would be allowed in C++ on, for instance, your computer, but we have since discovered that on the ARM processor we use, it will crash if that cast makes it read in a way that breaks their assumption that variables we word-aligned</p>
<p>These functions are then called in a parent class function that implements the sensor presence bit setting logic similar to the previous semester, allowing a packet to have any combination of sensor data in it, while still being decodable to the ground station.</p>
<h2><a class="anchor" id="autotoc_md29"></a>
Checksum</h2>
<p>Finally, the last part of the packet is a checksum, which is used to determine if there have been any bits flipped in the rest of the packet. You can read more about how they work here: <a href="https://en.wikipedia.org/wiki/Checksum">https://en.wikipedia.org/wiki/Checksum</a>. But essentially it relies on the rest of the packet to set its value and can be calculated by the ground station to check if it matches with what is transmitted, and if it isn’t there are bits that are wrong. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
